module Renaming where

import Control.Monad.State.Strict
import qualified Data.Map.Strict as M
import Data.Maybe
import Data.List (intercalate)
import Control.Applicative
import qualified Data.Set as S
import Debug.Trace
import Tokens
import Errors


type BoundVariableCounter = (FreshBV, Scope)

type FreshBV = M.Map String Integer
type Scope = M.Map String String


-- With type variables, we need to know how many preceding type variables of that name
-- there were, and whether or not a type variable of that name is in scope.
-- Basic logic is, if t.v. in scope, use its current name, and if not, create new and
-- use that along with setting to in scope.
type TypeVariableCounter = M.Map String (Integer, Bool)
    
data VariableCounter = VC { boundVars :: BoundVariableCounter, typeVars :: TypeVariableCounter } deriving (Show)
    
type CheckState a = StateT VariableCounter (Either Error) a
    
    
incrementFreshBV :: String -> CheckState ()
incrementFreshBV prefix = modify' f
    where f (VC (fresh, scope) tV) = VC (M.insertWith (+) prefix 1 fresh, scope) tV
    
getCurrentFreshBV :: String -> CheckState String
getCurrentFreshBV prefix = do
    fresh <- fmap (\(VC (fresh, _) _) -> fresh) get 
    case fresh M.!? prefix of
        Just i -> return $ prefix ++ show i
        Nothing -> lift $ Left $ VariableRenamingFailure $ "Variable renaming error: could not find variable " ++ prefix
    
getNextFreshBV :: String -> CheckState String
getNextFreshBV prefix = do
    incrementFreshBV prefix
    getCurrentFreshBV prefix

    
alterScope :: String -> String -> CheckState ()
alterScope oldPrefix newBinding = modify' f
    where f (VC (fresh, scope) tV) = VC (fresh, M.insert oldPrefix newBinding scope) tV

-- need to alter this to take different built-ins
getCurrVarName :: S.Set String -> String -> CheckState String
getCurrVarName initialAbs prefix = do
    scope <- extractScope
    case scope M.!? prefix of
        Just vName -> return vName
        Nothing -> if prefix `elem` initialAbs 
                   then return prefix
                   else lift $ Left $ VariableRenamingFailure $ "Could not find variable of name " ++ prefix
            
-- Binds the given variable prefix in the scope under a fresh variable name,
-- and returns the old scope for later reversion once this variable is dealt with.
bindVariable :: String -> CheckState Scope
bindVariable prefix = do
    oldScope <- extractScope
    freshBV <- getNextFreshBV prefix
    alterScope prefix freshBV
    return oldScope

revertScope :: Scope -> CheckState ()
revertScope oldScope = modify' f
    where f (VC (fresh, _) tV) = VC (fresh, oldScope) tV
            
extractScope :: CheckState Scope
extractScope = fmap (\(VC (_, scope) _) -> scope) get 
            
    
    
-- And for the tuple let-bindings, where we need multiple variables bound
-- and multiple current variable names...
getCurrVarNames :: S.Set String -> [String] -> CheckState [String]
getCurrVarNames initialAbs = mapM (getCurrVarName initialAbs)
    

bindVariables :: [String] -> CheckState Scope
bindVariables prefixes = do
    oldScope <- extractScope
    freshBVs <- mapM getNextFreshBV prefixes
    mapM_ (uncurry alterScope) (zip prefixes freshBVs)
    return oldScope
    
{- For getType: we'll be calling this on the type T of an abstraction's bound var x:T
   in \x:T.t1
   
   We're not only looking up a specific type / type variable, but also potentially
   creating new type variables for the type scope. So we need to pass the type scope 
   through all the types we encounter while renaming T (recursively).
   
   Once we have looked at T, we'll know which type variables were introduced, and should
   be passed down into the renaming of t1.
   
   But once we're done with x:T, we'll need to remove all the modifications we made when
   analysing T.
   
   So we introduce an undo function for each type scope change made, and the result of getType
   should include the composition of all undo functions generated by this step of renaming.
   
   One important point here - it shouldn't matter what order undo functions are applied in.
   
-}
     
type UndoFn = VariableCounter -> VariableCounter

-- The undo that does nothing to the state
undoNone :: UndoFn
undoNone = id
    
-- The undo function removing the type variable with the given name from the state
undoNamed :: String -> UndoFn
undoNamed name = \(VC bV tV) -> VC bV (M.adjust (\(count, _) -> (count, False)) name tV)
    
-- Doesn't matter if we use foldr or foldl, since (.) is associative
compUndo :: [UndoFn] -> UndoFn
compUndo = foldr1 (.)
    

tvInScope :: String -> TypeVariableCounter -> Bool
tvInScope name tvCounter = 
    case tvCounter M.!? name of
        Just (_, b) -> b
        _           -> False
    

-- Here we have to handle both creation of fresh type variables and incrementing
-- the number on those that already exist.
createNewTypeVariable :: String -> TypeVariableCounter -> TypeVariableCounter
createNewTypeVariable name tvCounter = 
    case tvCounter M.!? name of
        Just (count, _) -> M.insert name (count + 1, True) tvCounter
        Nothing -> M.insert name (1, True) tvCounter
    
    
-- Increments type variable where necessary, setting variable to in-scope, returning the undo that removes
-- the type variable from scope when required
incrTypeVar :: String -> CheckState UndoFn
incrTypeVar name = state $ 
    \(VC bV tV) -> if tvInScope name tV
                   then (undoNone, VC bV tV)
                   else (undoNamed name, VC bV (createNewTypeVariable name tV))
        
            
            
-- Requires that String be in the TypeVariableCounter map, so a preceding call must be made to incrTypeVar.
getTypeVar :: String -> CheckState Type
getTypeVar name = state $ 
    \(VC bV tV) -> 
        let tvName = name ++ (show . fst) (tV M.! name)
        in (TypeVariable tvName, VC bV tV)
    
type BoundTVs = M.Map String (Integer, Bool)

    
getTypeTuple :: [String] -> Maybe TypeLookup -> CheckState (Type, UndoFn)

getTypeTuple vNames t = 
    let vName = "{" ++ intercalate "," vNames ++ "}"
    in getType vName t

    
getType :: String -> Maybe TypeLookup -> CheckState (Type, UndoFn)

-- getType vName Nothing = lift $ Left $ VariableRenamingFailure $ "Variable not typed: " ++ vName ++ "; this is forbidden in explicit typing."

getType vName Nothing = return (UntypedVariable, undoNone)

getType vName (Just t) = getType' vName t

getType' :: String -> TypeLookup -> CheckState (Type, UndoFn)


-- Here's the tricky bit.
-- 1) If a type constant of name exists, return that type constant, and no undo
-- 2) If a type variable of name is in scope, return that type variable as name + number, and no undo
-- 3) If a type variable of name does not exist, mark that type variable name as in scope,
--    increment the number associated with that type variable, return that type variable as name + number,
--    and set an undo to remove that type variable from scope once the current abstraction is handled.
getType' vName (TypeConstantLookup name) = 
    case builtInType M.!? name of
        Just t -> return (t, undoNone)
        Nothing -> do
            undo <- incrTypeVar name
            t <- getTypeVar name
            return $ (t, undo)
    

-- We convert this into a 'type constructor' that doesn't do anything,
-- it's just a means of storing which type constructor needs to be 
-- looked up during type checking, and its type parameters
getType' vName (TypeConstructorLookup name argLookups) = do
    argsU <- mapM (getType' vName) argLookups
    let (args, undos) = unzip argsU
    case typeConstructors M.!? name of
        Just argCount -> if length argLookups == argCount
                         then return $ (TypeConstructor name args, compUndo undos)
                         else lift $ Left $ VariableRenamingFailure $ "Type constructor lookup failed for variable " ++ vName ++ ": type constructor " ++ name ++ " was given " ++ (show . length) argLookups ++ " type arguments, and needed " ++ show argCount
        Nothing -> lift $ Left $ VariableRenamingFailure $ "Type constructor lookup failed for variable " ++ vName ++ ": " ++ name ++ " not found."
    

getType' vName (FunctionLookup fromL toL) = do
    (from, undoFrom) <- getType' vName fromL
    (to, undoTo) <- getType' vName toL
    return $ (FunctionType from to, undoFrom . undoTo)
    
getType' vName (TupleLookup argLookups) = do
    argsU <- mapM (getType' vName) argLookups
    let (args, undos) = unzip argsU
    return $ (TupleType args, compUndo undos)

   
    
toExpr :: S.Set String -> RawExpr -> Either Error Expr
toExpr initialAbs r = fmap fst $ runStateT (toExpr' initialAbs r) (VC (M.empty, M.empty) M.empty)


toExpr' :: S.Set String -> RawExpr -> CheckState Expr




{-
toExpr' (RApplication re1 re2) = do
    e1 <- toExpr' re1
    e2 <- toExpr' re2
    return $ Application e1 e2
-}

toExpr' initialAbs (RApplication re1 re2) = liftA2 Application (toExpr' initialAbs re1) (toExpr' initialAbs re2)
  
  
{-
toExpr' (RVar rv) = do
    v <- getCurrVarName rv
    return $ Var (VarName rv v)
-}
toExpr' initialAbs (RVar rv) = Var . VarName rv <$> (getCurrVarName initialAbs rv)


toExpr' initialAbs (RLambda (RLambdaVariable (RawTypedVar rvName rvType)) re) = do
    oldBVScope <- bindVariable rvName
    (t, undo) <- getType rvName rvType 
    v <- getCurrVarName initialAbs rvName
    e <- toExpr' initialAbs re
    modify' undo
    revertScope oldBVScope
    return $ Lambda (LambdaVariable (TypedVar (VarName rvName v) t)) e
    

toExpr' initialAbs (RLambda (RLambdaTuple (RawTypedTupleVar rVNs rVT)) re) = do
    oldBVScope <- bindVariables rVNs
    (t, undo) <- getTypeTuple rVNs rVT
    vs <- getCurrVarNames initialAbs rVNs
    e <- toExpr' initialAbs re
    modify' undo
    revertScope oldBVScope
    let vNs = map (uncurry VarName) (zip rVNs vs)
    return $ Lambda (LambdaTuple (TypedTupleVar vNs t)) e
    
    
{-
toExpr' (RLit l) = do
    return $ Lit l
-}
toExpr' initialAbs (RLit l) = pure $ Lit l


{-
toExpr' (RIf reC reT reE) = do
    eC <- toExpr' reC
    eT <- toExpr' reT
    eE <- toExpr' reE
    return $ EIf eC eT eE
-}
toExpr' initialAbs (RIf reC reT reE) = liftA3 EIf (toExpr' initialAbs reC) (toExpr' initialAbs reT) (toExpr' initialAbs reE)

{-
toExpr' (RTup reL) = do
    eL <- mapM toExpr' reL
    return $ ETup eL    
-}
toExpr' initialAbs (RTup reL) = liftA ETup (mapM (toExpr' initialAbs) reL)


toExpr' initialAbs (RTupAcc re digit size) = do
    e <- toExpr' initialAbs re
    return $ ETupAcc e digit size

--toExpr' (RTupAcc re digit size) = ETupAcc <$> (toExpr' re) <*> lift digit <*> lift size


-- For let-expressions, we're doing precisely what we were doing for 
-- variables except without explicitly assigning the variable a type.
-- That is, we evaluate the binding, then assign the name to the binding
-- in the inExpr. From point of view of conversion from raw, we evaluate the
-- raw binding to an expression, then add the name to the bound variables, then
-- toExpr' the raw inExpr with the new bound variable scope.
toExpr' initialAbs (RLet (RLetVar rvName) rBinding rInExpr) = do
    binding <- toExpr' initialAbs rBinding
    oldBVScope <- bindVariable rvName
    v <- getCurrVarName initialAbs rvName
    inExpr <- toExpr' initialAbs  rInExpr
    revertScope oldBVScope
    return $ ELet (LetVar (VarName rvName v)) binding inExpr
    

-- For lets with tuples, things are slightly more complicated, but still the same idea
toExpr' initialAbs (RLet (RLetTuple rvNames) rBinding rInExpr) = do
    binding <- toExpr' initialAbs rBinding
    oldBVScope <- bindVariables rvNames
    vs <- getCurrVarNames initialAbs rvNames
    inExpr <- toExpr' initialAbs rInExpr
    revertScope oldBVScope
    return $ ELet (LetTuple $ map (uncurry VarName) (zip rvNames vs)) binding inExpr
    
   
    