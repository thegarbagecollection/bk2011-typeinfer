RIPL instructions:
------------------
Read-Infer-Print Loop; not really a REPL, since the only thing "evaluated" is the type.

For all RIPLs, to quit, give 'Q' or 'q' as an expression.

These were all built on a Windows 7 desktop; instructions given at the end for recompiling if needed.


Binding at RIPL-level:
---------------------
Since this lambda calculus syntax does not allow for multiple programs, we allow binding at the RIPL level.

  @name=expr

assuming expr is typable with type T, binds <name> to type T from that point on in the RIPL session (unless overwritten). e.g.
  
  @id=\x.x

binds id to the identity;

  @map=fix (\map.\f.\xs.cons (f head xs) (map f (tail xs)))

binds map to the map abstraction (T->U)->List(T)->List(U):

> Hindley-Milner inference: standard RIPL, no file output; q or Q to quit
> 
> @map=fix (\map.\f.\xs.cons (f (head xs)) (map f (tail xs)))
> (1) Success: (?T7->?T8)->List(?T7)->List(?T8)
> 
> map
> (2) Success: (?T1->?T2)->List(?T1)->List(?T2)

Between RIPL invocations, it relabels all parametrically polymorphic function types.


Multiline RIPL
--------------
Multi-line expressions are handled at the RIPL level as follows: 
- start a multiline expression with '#'
- the RIPL will interpret anything up to another '#' as being part of the same line with the following rules
    all newlines are removed
    all tabs are converted to spaces
    adjacent spaces are merged to a single space
    spaces are stripped from the start of every line
    everything after the second '#' is discarded.
    
For example, where for convenience I have marked explicit line-ending and -beginning whitespace as underscores
> Hindley-Milner inference: standard REPL, no file output; q or Q to quit
>
> #
> @map=
> _fix_
> ___(\map.\f.\xs.
> ______cons (f (head xs))_
> ________(map f (tail xs)))
> #
(1) Success: (?T7->?T8)->List(?T7)->List(?T8)

note the spaces after the "fix " and "cons (f (head xs)) " to force application.




Standard, simple RIPL
---------------------
riplG: greedy inference, Section 5
riplHM: Hindley-Milner, Section 6
riplBK: B&K2011, Section 7 and on

Given an input expression, displays the resulting type (and time, if B&K2011) on screen, or an error message if failed.


File-writer RIPL
----------------
friplG: greedy inference
friplHM: Hindley-Milner
friplBK: B&K2011

Must be run with an argument <dir> - the directory to put the results in.

Given an input expression, displays the resulting type (and time, if B&K2011) on screen, or an error message if failed.
Additionally, writes the following files in the RIPL directory:

For all 3 RIPLs, given an item entered in RIPL iteration i (shown by the printout in parens)
  <dir>/i-type.txt is the expression and the resulting type, if any, or an error.

For HM and B&K2011 file RIPLs, the type constraints generated by the constraint typing rules
  <dir>/typeconstraints/<i>-types.ty        

For B&K2011 file RIPL:
  The respective graphs G, H; also H after successful execution, all GraphViz dot-graph format
    <dir>/graphviz/<i>-G.dg           
    <dir>/graphviz/<i>-H-1.dg  
    <dir>/graphviz/<i>-H-2.dg  

  Time constraints in the format I was using for Haskell input
    <dir>/timeconstraints/<i>-times.tc        

  Time constraints, for human reading
    <dir>/timeconstraints/<i>-times.hc       


    
Syntax examples:
---------------
\x.x                                  abstraction, implicit typing
\x:T.x                                abstraction with T explicitly bound 
\x:Bool.x                             abstraction, x is a Bool
\x:Nat y:Bool.0                       automatic nested abstraction, x as Nat and y as Bool
(\x.x) 0                              directly applied abstraction
\f.\x.f x                             application - space-separated
\f x.f x                              application, using automatic nested abstraction 
succ 0                                application of built-in
\x:List(T).\y:T.cons y x              type constructor List(T)
let x=(succ 0) in (...)               standard let expression; use parens for expressions due to difficulties with the priorities
let x=(succ 0);y=(succ x) in (...)    automatic nested let expression ; again use parens for the expression
\x y.{x,y}                  tuple creation - no space after the comma!
{x,y}.1                     tuple pair accessor - no space after the comma!
{x,y,z}.2(3)                n-tuple accessor with explicit type annotation of 3-tuple.
let {a,b}=(e) in (...)      let expression with tuple deconstructor; again use parens for expressions
\{a,b}.cons a b             abstraction with tuple deconstructor
\x.*x                       bullet notation
\x.await (*x)               both await and bullet notation
0                           literals
true
false

   
Built-ins for all:
succ : Nat -> Nat 
pred : Nat -> Nat
iszero : Nat -> Nat

Built-ins for greedy and Hindley-Milner:
List(T) type constructor
cons : T -> List(T) -> List(T)
head : List(T) -> T
tail : List(T) -> List(T)
fix : (T -> T) -> T
badnil : List(T)

Built-ins for B&K2011:
InfList(T) type constructor
cons : T -> InfList(T) -> InfList(T)
head : InfList(T) -> T
tail : InfList(T) -> *InfList(T)
fix : (*T -> T) -> T
badnil : InfList(T)


TROUBLESHOOTING
---------------

If a binary doesn't work:
- install Haskell Stack; exact means depends on system
- navigate to the root directory of the binary's source code; it has a ".cabal" file in it
- enter

stack install

  then

stack build

  and wait for the build to finish - all dependencies are in the cabal file, so it should be automatic.
- enter

stack exec "<filename>"

and it should bring up the REPL with a message indicating which REPL it is.

or just navigate to the appropriate directory indicated by the build step and run the executable directly.


Graph visualisation: files are written in GraphViz DOT graph format.
- install GraphViz, make sure it's in the path; can test with
 
dot -Tpng test.dg > test.png

  with the enclosed test file test.dg; a 3-vertex 2-edge directed graph.
- copy the file "graph-to-png.sh" into the directory containing all the .dg files
- execute graph-to-png.sh
- this should create one PNG image for every .dg graph file output by the REPL.